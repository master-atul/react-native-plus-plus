# Presentational Components VS Container Components
When writing code in React or React Native, we often wonder how to structure our code so that it makes our life much easier with handling all state changes, data flow and renders, etc. There is a pattern which helps organizing React based applications - splitting the components into presentational and containers.

### Presentational components
Presentational components are those components whose only job is to render a view according the styling and data passed to it.
In essence they do not have any business logic in them. That is why they are sometimes also called 'dumb components'.
This means that they don't have direct access to redux or other data stores. Data is passed onto them as props.
According to Dan Abramov via his blog https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0,

In a nutshell, presentational components:
- are concerned with how things look.
- have markup and styles of their own.
- Have no dependencies on the rest of the app, such as redux stores.
- don’t specify how the data is loaded or mutated.
- receive data and callbacks exclusively via props.
- rarely have their own state (when they do, it’s UI state rather than data).

An example of a Dumb/Presentational component would be :

```js
import React, {Component} from 'react';
import {View} from 'react-native';
import styles from './Header.component.style';

class Header extends Component {
  render () {
    const {title, subtitle} = this.props;
    return (
      <View style={styles.container}>
        <View style={styles.titleHeading}>{title}</View>
        <View style={styles.subtitle}>{subtitle}</View>
      </View>
    );
  }
}
export default Header;
```

### Container components

Container components are those React components which have access to the store. These components make api calls, do processing and contain the business logic of the app. Container components shouldn't have the view logic or presentational logic. The job of container component is to compute the values and pass them as props to the presentational components. Hence these components are sometimes also referred to as Smart Components.

Hence, Container components:
- are concerned with how things work.
- don’t usually have any markup of their own except for some wrapping Views, and never have any styles.
- provide the data and behavior to presentational or other container components.
- call redux actions and provide these as callbacks to the presentational components.
- are often stateful, as they tend to serve as data sources.
- are usually generated using higher order components such as connect() from React Redux, createContainer() from Relay, or  Container.create() from Flux Utils, rather than written by hand.


An example of Smart/Container component would be:
 ```js
 import React, {Component} from 'react';
 import Header from '../component/Header.component';

 class Home extends Component {
   calculateSomething = () => {
     ...some calculation / api calls....
   }
   render () {
     const {title, subtitle, goToLogin} = this.props;
     return (
       <Header title={title} subtitle={subtitle} goToLogin={goToLogin} calculateSomething={this.calculateSomething}/>
     );
   }
 }
 const mapStateToProps = (state)=>{
   return {
     title: state.title,
     subtitle: state.subtitle
   };
 };

 const mapDispatchToProps = (dispatch) => {
   goToLogin: () => dispatch({action:'GO_TO_LOGIN'})
 };

 export default connect(mapStateToProps, mapDispatchToProps)(Home);
 ```
 
In the above example, if you notice our Container components do not do any kind of layouting or styling. It only manages the business logic. This helps us separate the concerns "Styling/Layouting" and "Business Logic".

The Container-Presentational pattern gives us many benefits:

- Less code duplication. Because you are now forced to move all the layout components out as separate presentational components, you can now directly reuse them instead of copy-pasting the code in every page.
- Presentational components are essentially your app’s View layer. Hence, you can change the styling without touching the app's logic.
- Better separation of concerns. You understand your app and your UI better by writing components this way.
- Better reusability. You can use the same presentational component with completely different state sources, and turn those into separate container components that can be further reused.


## Back to Code

Lets say in our note taker app. We need to add the character count and a save/sync button at bottom.
First lets create the UI component for it.

Modify the files
**`app/components/Home/Home.component.js`**
```js
...
...
...
           onChangeText={this.setTitle} value={this.state.title} />
         <Text style={styles.textAreaTitle}> Please type your note below </Text>
         <TextArea style={styles.textArea}/>
         <View style={styles.bottomBar}>
           <View style={styles.bottomBarWrapper}>
             <Text style={styles.saveBtn}>Save</Text>
             <Text style={styles.characterCount}>{20} characters</Text>
           </View>
         </View>
       </View>
     );
   }
```
**`app/components/Home/Home.component.style.js`**
```js
 export default StyleSheet.create({
   container: {
     flex: 1,
     paddingTop: theme.CONTAINER_PADDING,
     flexDirection: 'column',
     justifyContent: 'space-between'
   },
   ...
   ...
   ...
   ...
   textArea: {
     ...textInput,
     flex: 1
   },
   bottomBar: {
     flexDirection: 'row',
     alignItems: 'center'
   },
   bottomBarWrapper: {
     flexDirection: 'row',
     justifyContent: 'space-between',
     flex: 1
   },
   saveBtn: {
     padding: 10,
     fontWeight: theme.FONT_WEIGHT_BOLD
   },
   characterCount: {
     padding: 10,
     fontSize: theme.FONT_SIZE_SMALL
   }
 });
 ```
**`app/styles/theme.style.js`**
```js
   ...
   ...
   BACKGROUND_COLOR_LIGHT: '#ebe9e9',
   ...
   ...
 };
```

Now our app should have a bottom bar with character count and a save button.
Currently we have hard coded the character count to 20.

<br/>
<div style="text-align:center">
  <img src="/assets/images/9/9.2/9.2-bottom-bar.png" style="width: 40%;display:inline-block;" hspace="40" />
</div>
<br/>

But if you look at the app now, there is no way for us to get the character count from the TextArea component and use it as the text for character count text view.
To do this we will need to **move the state present inside the TextArea component and place it in the Home component**.
This is because all the components that need access to a state have to be the child of the component holding the state.

So we modify our components as follows:
**`app/components/TextArea/TextArea.component.js`**
```js
import React, {Component} from 'react';
import {TextInput} from 'react-native';
import PropTypes from 'prop-types';
import styles from './TextArea.component.style';

class TextArea extends Component {
  static propTypes = {
    text: PropTypes.string,
    onTextChange: PropTypes.func
  }
  render () {
    const {text, onTextChange, ...extraProps} = this.props;
    return (
      <TextInput
        {...extraProps}
        style={[styles.textArea, extraProps.style]}
        multiline = {true}
        onChangeText={onTextChange}
        value={text}
      />
    );
  }
}
export default TextArea;
```
**`app/components/Home/Home.component.js`**
```js
import React, {Component} from 'react';
import {View, Text, TextInput} from 'react-native';
import styles from './Home.component.style';
import TextArea from '../TextArea/TextArea.component';

class Home extends Component {
  state = {
    title: '',
    text: ''
  }
  setTitle = (title) => this.setState({title})
  setText = (text) => this.setState({text});
  render () {
    return (
      <View style={styles.container}>
        <Text style={styles.titleHeading}> Note Title</Text>
        <TextInput style={styles.titleTextInput}
            onChangeText={this.setTitle} value={this.state.title} />
        <Text style={styles.textAreaTitle}> Please type your note below </Text>
        <TextArea text={this.state.text} onTextChange={this.setText} style={styles.textArea}/>
        <View style={styles.bottomBar}>
          <View style={styles.bottomBarWrapper}>
            <Text style={styles.saveBtn}>Save</Text>
            <Text style={styles.characterCount}>{this.state.text.length} characters</Text>
          </View>
        </View>
      </View>
    );
  }
}
export default Home;
```
The character count should now update whenever you enter text on the text field.

<br/>
<div style="text-align:center">
  <img src="/assets/images/9/9.2/9.2-bottom-bar.png" style="width: 40%;display:inline-block;" hspace="40" />
</div>
<br/>


Hence, here by moving the state from the child component to parent, we were able to access it in multiple child components.
Thus, to provide access to the data that needs to be accessed by multiple components, we need to have the state in the enclosing parent component.

Redux builds on top of similar principles. It keeps a global store to which the components which need access to the data can subscribe to. Additionally it provides a mechanism by which these components can re-render whenever the data in the store changes.

Now, since we are clear why redux is helpful.

Lets organize our project to include
